#!/usr/bin/env python3

import os
import re
import shutil
import subprocess
import sys

from VTcolors import *

PROGRAM = "VTbuild"
DEBUG_MODE = False  # Set to True for debugging
if "--debug" in sys.argv:
    debug_index = sys.argv.index("--debug")
    sys.argv.pop(debug_index)
    DEBUG_MODE = True
    print_coloured(DEBUG, "mode activated.")


# Displays help information about how to use the program.
def help_build():
    text = f"""
{PROGRAM} must receive at least one argument.
To show this help page: 
    Usage: python VTbuild.py --help

Create a build directory containing all the compiled hardware:
    Usage: python VTbuild.py <main_module> --TestBench <testbench_name> --Boards <board_modules> --quiet --debug
    <main_module> -> This is the name of the main RTL design.
    --TestBench <testbench_name> (optional) -> by default VTbuild looks for a TestBench file with the name <main_module>_tb.
    --Boards <board_modules> (optional) -> by default VTbuild looks for NO board RTL design top module. Multiple boards can be passed in a single argument (example, "Board1 Board2 Board3").
    --quiet (optional) -> suppresses INFO prints.
    --debug (optional) -> enables DEBUG prints.

Clean the contents generated by VTbuild:
    Usage: python VTbuild.py --clean all
    all (optional) -> By default "--clean" only removes the "build" directory, with "all" it also removes the "hardware/generated" directory.

"""
    print_coloured(INFO, text)


# Cleans the build directory by removing it and its contents.
def clean_build(current_directory):
    directory_to_remove = f"{current_directory}/build"
    remove_directory(directory_to_remove)
    if (len(sys.argv) > 2) and (sys.argv[2] == "all"):
        directory_to_remove = f"{current_directory}/hardware/generated"
        remove_directory(directory_to_remove)


# Removes a directory and its contents.
# Args:
#   directory_to_remove: The directory to remove.
def remove_directory(directory_to_remove):
    try:
        shutil.rmtree(directory_to_remove)
        print_coloured(
            OK, f"Removed directory '{directory_to_remove}' and its contents."
        )
    except OSError as e:
        print_coloured(WARNING, f"Could not remove directory. {e}")


# Finds all verilog snippets, modules, and scripts under the given directory.
# Args:
#   directory: The directory to search.
# Returns:
#   A lists of all verilog snippets, modules, and scripts found in the directory.
def find_verilog_and_scripts(current_directory):
    script_files = []
    verilog_files = []
    search_directories = []
    excluded_files = ["LICENSE", ".gitignore", ".gitmodules"]
    verilog_extensions = [".v", ".vh", ".sv", ".svh", ".vs"]
    script_extensions = ["", ".py", ".sh"]

    # Find the index of the search_term in the path
    index = sys.argv[0].rfind("MyVT-Tool")
    if index != -1:
        VTbuild_directory = f"{sys.argv[0][:index]}MyVT-Tool"
    else:
        VTbuild_directory = sys.argv[0]

    search_directories.append(current_directory)
    search_directories.append(VTbuild_directory)
    search_directories += get_included_directories()
    for directory in search_directories:
        for root, dirs, files in os.walk(directory, topdown=True):
            dirs[:] = [
                d
                for d in dirs
                if (".git" not in d) and (d != "build") and (d != "hardware/generated")
            ]
            for file in files:
                filename, extension = os.path.splitext(file)
                if filename not in excluded_files:
                    if extension in script_extensions:
                        script_files.append(os.path.join(root, file))
                    elif extension in verilog_extensions:
                        verilog_files.append(os.path.join(root, file))

    if DEBUG_MODE:
        print_coloured(DEBUG, f"Found verilog files:")
        for verilog_file in verilog_files:
            print_coloured(DEBUG, verilog_file)
        print_coloured(DEBUG, f"Found script files:")
        for script_file in script_files:
            print_coloured(DEBUG, script_file)

    return script_files, verilog_files


# Get the directories the user wants to include from the .
# Args:
#   None. Reads the sys.argv.
# Returns:
#   A list of the directories to include when searching for scripts and Verilog.
def get_included_directories():
    included_directories = []

    if "--inc_dir" in sys.argv or "-I" in sys.argv:
        include_index = 3  # need to get id.
        included_directories.append(sys.argv[include_index])

    return included_directories


# Fetch verilog files, generating them if necessary.
# Args:
#   verilog_files (list): List of existing verilog file paths.
#   script_files (list): List of script file paths.
# Returns:
#   A list of all verilog files used by the core.
def fetch_sources(verilog_files, script_files, top_module):
    sources_list = []
    sources_list, verilog_files = find_or_generate(
        "", tuple([top_module]), script_files, verilog_files, sources_list
    )
    generated_path = f"{current_directory}/hardware/generated"
    create_directory(generated_path)
    i = 0

    while i < len(sources_list):
        verilog_file = sources_list[i]
        sources_list, verilog_files = analyse_file(
            verilog_file, script_files, verilog_files, sources_list
        )
        i = i + 1

    return sources_list


# Analyze a verilog file for module instantiations or includes.
# Args:
#   file_path (str): Path to the verilog file.
#   script_files (list): List of script file paths.
#   verilog_files (list): List of verilog file paths.
# Returns:
#   list: List of additional source file paths.
def analyse_file(file_path, script_files, verilog_files, sources_list):
    with open(file_path, "r") as file:
        content = file.read()
    filename = os.path.basename(file_path)

    module_pattern = r"(.*?)\n?\s*#?\(\n([\s\S]*?)\);\n"
    inline_module_pattern = r"(?<!\S)(\w+)\s+?(\w+)\s*?\(\.(.+?)\);"
    include_pattern = r'(?<!\S)`include "(.*?)"(?!\s*?/\*)(.*?)\n'
    include_with_multi_line_comment = (
        r'(?<!\S)`include "(.*?)"\s*/\*\s*?\n([\s\S]*?)\n\s*?\*/\n'
    )
    for pattern in [
        module_pattern,
        inline_module_pattern,
        include_pattern,
        include_with_multi_line_comment,
    ]:
        matches = re.findall(pattern, content)
        for item in matches:
            if not item[0].startswith("module "):
                sources_list, verilog_files = find_or_generate(
                    filename, item, script_files, verilog_files, sources_list
                )

    return sources_list, verilog_files


# Find or generate a file based on given conditions.
# Args:
#   str_list (list): Name of the file to find or generate.
#   script_files (list): List of script file paths.
#   verilog_files (list): List of verilog file paths.
#   match: Matched object from module pattern.
# Returns:
#   str: Path to the found or generated file.
def find_or_generate(
    callee_filename, str_list, script_files, verilog_files, sources_list
):
    current_directory = os.getcwd()
    file_path = None
    file_name = str_list[0].split()[0]
    _, extension = os.path.splitext(file_name)

    if extension == "":
        file_path = find_filename_in_list(f"{file_name}.v", verilog_files)
        if file_path is None:
            file_path = find_filename_in_list(f"{file_name}.sv", verilog_files)
    else:
        file_path = find_filename_in_list(file_name, verilog_files)

    if file_path is None:
        script_path, script_arg = find_most_common_prefix(file_name, script_files)
        if script_path != "":
            script_arguments = [
                "python",
                script_path,
                script_arg,
                str_list[1],
                callee_filename,
            ] + sys.argv[1:]
            subprocess.run(script_arguments)
            sources_list, verilog_files = move_to_generated_dir(
                script_path, current_directory, sources_list, verilog_files
            )
    else:
        if file_path not in sources_list:
            sources_list.append(file_path)
        if extension == "":
            file_name = f"{file_name}.[v/sv]"
        print_coloured(INFO, f"File {file_name} exists under the current directory.")

    return sources_list, verilog_files


# Moves Verilog files generated by a script under the current directory to the generated directory.
# Args:
#   script_path (str): A string equivalent to the script path executed.
#   current_directory (str): A string equivalent to the current directory.
# Returns:
#   generated_dir (str): Directory of the generated files.
def move_to_generated_dir(script_path, current_directory, sources_list, verilog_files):
    verilog_extensions = [".v", ".vh", ".sv", ".svh", ".vs"]
    verilog_files_found = []
    generated_dir = os.path.join(current_directory, "hardware/generated/")

    for filename in os.listdir(current_directory):
        _, extension = os.path.splitext(filename)
        file_dst_path = os.path.join(generated_dir, filename)
        file_src_path = os.path.join(current_directory, filename)
        if extension in verilog_extensions:
            shutil.move(file_src_path, file_dst_path)
            verilog_files_found.append(file_dst_path)
            if file_dst_path not in verilog_files:
                verilog_files.append(file_dst_path)
            if file_dst_path not in sources_list:
                sources_list.append(file_dst_path)

    if verilog_files_found == []:
        print_coloured(WARNING, f"{script_path} generated no Verilog files.")
    else:
        print_coloured(
            INFO, f"{script_path} generated {', '.join(verilog_files_found)}."
        )

    return sources_list, verilog_files


# Searches for the file with the most common prefix in a file list.
# Args:
#   file_name (str): A string equivalent to the file name to search for.
#   file_list (list): A list of script file names.
# Returns:
#    tuple: A tuple containing the file path and the remaining string words.
def find_most_common_prefix(file_name, file_list):
    filename_without_extension = os.path.splitext(file_name)[0]
    input_words = filename_without_extension.split("_")
    max_common_words = 0
    most_common_file = ""
    uncommon_words = ""

    for file_path in file_list:
        file_name = os.path.basename(file_path)
        filename_without_extension = os.path.splitext(file_name)[0]
        common_words = 0
        string_words = filename_without_extension.split("_")

        if len(input_words) > len(string_words):
            for i in range(len(string_words)):
                if input_words[i] == string_words[i]:
                    common_words += 1
                else:
                    break

        if common_words > max_common_words:
            max_common_words = common_words
            uncommon_words = "_".join(input_words[common_words:])
            most_common_file = file_path

    return most_common_file, uncommon_words


# Builds Verilog files and creates a build directory for RTL sources.
# Args:
#   module (str): The module name for Verilog files.
#   verilog_files (list): List of Verilog source file paths.
#   script_files (list): List of script file paths.
# Returns:
#   list: The list of RTL Verilog source files.
def rtl_build(module, verilog_files, script_files):
    rtl_dir = f"{current_directory}/build/RTL"
    rtl_sources = fetch_sources(verilog_files, script_files, module)
    verilog_copy(rtl_sources, [], rtl_dir)
    print_coloured(OK, "Built all RTL sources.")
    return rtl_sources


# Builds TestBench Verilog files and creates a build directory.
# Args:
#   TestBench (str): The TestBench name.
#   verilog_files (list): List of Verilog source file paths.
#   script_files (list): List of script file paths.
#   rtl_sources (list): List of RTL Verilog source files.
def testbench_build(TestBench, verilog_files, script_files, rtl_sources):
    testbench_dir = f"{current_directory}/build/TestBench"
    testbench_sources = fetch_sources(verilog_files, script_files, TestBench)
    verilog_copy(testbench_sources, rtl_sources, testbench_dir)
    copy_testbench_cpp(TestBench, testbench_dir)
    print_coloured(OK, "Built all TestBench sources.")


# Copies TestBench C++ file to the TestBench build directory.
# Args:
#   TestBench (str): The TestBench name.
#   testbench_dir (str): The directory for TestBench files.
def copy_testbench_cpp(TestBench, testbench_dir):
    for root, _, files in os.walk("."):
        if f"{TestBench}.cpp" in files:
            # Form the source and destination paths
            source_path = os.path.join(root, f"{TestBench}.cpp")
            destination_path = os.path.join(testbench_dir, f"{TestBench}.cpp")

            # Copy the file to the testbench_dir
            shutil.copy(source_path, destination_path)
            print_coloured(INFO, f"File '{source_path}' copied to '{destination_path}'")
            return

    print_coloured(
        INFO,
        f"File '{TestBench}.cpp' not found in the current directory or its subdirectories.",
    )


# Builds Verilog files for specified boards and creates a build directory.
# Args:
#   Boards (list): List of board names.
#   main_module (str): The main module name.
#   verilog_files (list): List of Verilog source file paths.
#   script_files (list): List of script file paths.
#   rtl_sources (list): List of RTL Verilog source files.
def board_build(Boards, main_module, verilog_files, script_files, rtl_sources):
    for Board in Boards:
        Board_name = Board
        if Board.startswith(main_module):
            Board_name = Board[len(main_module) :].lstrip("_")
        Board_dir = f"{current_directory}/build/RTL/{Board_name}"
        Board_sources = fetch_sources(verilog_files, script_files, Board)
        verilog_copy(Board_sources, rtl_sources, Board_dir)
        print_coloured(OK, f"Built all {Board_name} sources.")


# Copy Verilog files to build directories and substitute ".vs" on said files
# Args:
#   sources_list (list): List of Verilog source file paths.
#   build_dir (str): Path to the build directory.
def verilog_copy(new_sources, existing_sources, build_dir):
    sources_list = filter_list(new_sources, existing_sources)
    create_directory(build_dir)
    for verilog_file in sources_list:
        if not verilog_file.endswith(".vs"):
            verilog_content = ""
            verilog_content = substitute_vs_file(verilog_file, sources_list)
            file_name = os.path.basename(verilog_file)
            with open(f"{build_dir}/{file_name}", "w") as file:
                file.write(verilog_content)


# Filter common files between the target list and the source list
# Args:
#   target_list (list): List to be filtered.
#   source_list (list): Secondary source files list.
# Returns:
#   filtered_list (list): target_list filtered, remains with all ".vs" files and files not present in source_list.
def filter_list(target_list, source_list):
    # Create an empty list to store elements from target_list that are not in source_list
    filtered_list = []

    # Iterate through target_list and only add elements not present in source_list to filtered_list
    for element in target_list:
        if (element not in source_list) or (element.endswith(".vs")):
            filtered_list.append(element)

    return filtered_list


# Recursively substitutes included .vs files in the source file content.
# Args:
#   source_file: The source file containing potential `include directives.
# Returns:
#   The new content with included .vs files substituted.
def substitute_vs_file(source_file, sources_list):
    new_content = ""
    on_comment = False

    with open(source_file, "r") as file:
        for line in file:
            if not on_comment:
                match = re.search(r'(?<!\S)`include "(.*?)\.vs"(.*)', line)
                if match:
                    vs_file = match.group(1) + ".vs"
                    vs_file_path = find_filename_in_list(vs_file, sources_list)

                    if vs_file_path:
                        new_content += substitute_vs_file(vs_file_path, sources_list)
                    else:
                        warning_text = f"File {vs_file} does not exist to substitute."
                        print_coloured(WARNING, warning_text)
                        new_content += f"  // {warning_text}\n"
                    if "/*" in line:
                        on_comment = True
                else:
                    new_content += line
            else:
                if "*/" in line:
                    on_comment = False

    return new_content


# Finds the filename in the list of files.
# Args:
#   filename: The filename to find.
#   files_list: The list of files to search.
# Returns:
#   The first matching file, or None if the file is not found.
def find_filename_in_list(filename, files_list):
    found_files = None
    for file in files_list:
        if os.path.basename(file) == filename:
            if found_files != None:
                print_coloured(
                    WARNING,
                    f"Found more than one directory with file {filename}.",
                )
            found_files = file

    if found_files:
        return found_files
    else:
        return None


# Creates a directory at the specified path.
# Args:
#   path: The path of the directory to be created.
def create_directory(path):
    try:
        os.makedirs(path)
        print_coloured(INFO, f"Created directory '{path}'.")
    except OSError as e:
        if DEBUG_MODE:
            print_coloured(DEBUG, f"Did not create directory: {e}")


# Parses arguments with which VTbuild is called.
# Returns:
#   module_name (string): Name of the main module in the design.
#   testbench_name (string): Name of the design's TestBench.
#   board_modules (list): List with the name of the board top modules that are supported by the design.
def parse_arguments():
    module_name = sys.argv[1]
    testbench_name = f"{sys.argv[1]}_tb"
    board_modules = []

    i = 2
    while i < len(sys.argv):
        if sys.argv[i] == "--TestBench":
            if i + 1 < len(sys.argv) and not sys.argv[i + 1].startswith("--"):
                testbench_name = sys.argv[i + 1]
                if testbench_name.startswith("_"):
                    testbench_name = f"{module_name}{testbench_name}"
                i += 1  # Skip the next argument
            else:
                print_coloured(ERROR, "Invalid argument after --TestBench")
                help_build()
                return None, None, None
        elif sys.argv[i] == "--Boards":
            if i + 1 < len(sys.argv) and not sys.argv[i + 1].startswith("--"):
                Boards = sys.argv[i + 1].split()
                for Board in Boards:
                    if Board.startswith("_"):
                        board_modules.append(f"{module_name}{Board}")
                    else:
                        board_modules.append(Board)
                i += 1  # Skip the next argument
            else:
                print_coloured(ERROR, "Invalid argument after --Boards")
                help_build()
                return None, None, None
        i += 1

    return module_name, testbench_name, board_modules


# Check if this script is called directly
if __name__ == "__main__":
    current_directory = os.getcwd()
    if len(sys.argv) < 2 or sys.argv[1] == "--help":
        help_build()
    elif sys.argv[1] == "--clean":
        clean_build(current_directory)
    else:
        main_module, testbench, board_modules = parse_arguments()
        if main_module != None:
            script_files, verilog_files = find_verilog_and_scripts(current_directory)
            rtl_sources = rtl_build(main_module, verilog_files, script_files)
            testbench_build(testbench, verilog_files, script_files, rtl_sources)
            board_build(
                board_modules, main_module, verilog_files, script_files, rtl_sources
            )
            print_coloured(OK, f"Created {main_module} project build directory.")
